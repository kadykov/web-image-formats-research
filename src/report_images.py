"""Image optimization for the web report.

Prepares comparison images generated by :mod:`src.comparison` for
efficient delivery via the static HTML report.  Two pipelines are
provided:

* **Lossless integer-scaled** — for fragment comparison grids where
  pixel fidelity is critical.  Generates 1×, 2× and 3× variants using
  nearest-neighbour resampling so that each original source pixel maps
  to exactly 1×1, 2×2 or 3×3 device pixels respectively.

* **Lossy multi-format** — for distortion maps, annotated originals and
  other visualisation images where minor compression artefacts are
  acceptable.  Produces AVIF (quality 60, YUV444) and WebP lossy
  variants at multiple widths for ``<picture>``/``srcset`` delivery.

Both pipelines write optimised files into the report output tree and
return metadata used by the Jinja templates to emit correct ``<img>``
or ``<picture>`` markup.
"""

from __future__ import annotations

import subprocess
from dataclasses import dataclass, field
from pathlib import Path

from PIL import Image

# ---------------------------------------------------------------------------
# Data structures
# ---------------------------------------------------------------------------


@dataclass
class ImageVariant:
    """A single optimised image file.

    Attributes:
        path: Absolute path to the file on disk.
        rel_path: Path relative to the report output root (for HTML ``src``).
        width: Pixel width.
        height: Pixel height.
        media_type: MIME type (``image/webp``, ``image/avif``, …).
        lossless: Whether the variant is losslessly encoded.
    """

    path: Path
    rel_path: str
    width: int
    height: int
    media_type: str
    lossless: bool = False


@dataclass
class OptimisedImage:
    """Collection of variants for a single source image.

    Attributes:
        source_path: Original (unoptimised) file.
        alt: Alt-text for the ``<img>`` element.
        kind: One of ``"lossless"`` or ``"lossy"`` indicating the
            optimisation pipeline used.
        variants: All generated variants, grouped by MIME type.
        default: The variant to use as the ``<img src>`` fallback.
    """

    source_path: Path
    alt: str
    kind: str  # "lossless" | "lossy"
    variants: dict[str, list[ImageVariant]] = field(default_factory=dict)
    default: ImageVariant | None = None


@dataclass
class ComparisonImageSet:
    """All optimised images for one strategy (or resolution within a strategy).

    Attributes:
        strategy: ``"average"`` or ``"variance"``.
        resolution: Resolution label (e.g. ``"r720"``) or ``None``.
        original_annotated: The annotated original image.
        distortion_map: The aggregated distortion map.
        fragment_grids: Fragment comparison grids (may be >1 when split
            by a varying parameter).
        distmap_grids: Distortion-map comparison grids (same cardinality
            as *fragment_grids*).
    """

    strategy: str
    resolution: str | None = None
    original_annotated: OptimisedImage | None = None
    distortion_map: OptimisedImage | None = None
    fragment_grids: list[OptimisedImage] = field(default_factory=list)
    distmap_grids: list[OptimisedImage] = field(default_factory=list)


@dataclass
class StudyComparisonImages:
    """All comparison image sets for a study.

    Attributes:
        study_id: Study identifier.
        sets: Per-strategy (and optionally per-resolution) image sets.
    """

    study_id: str
    sets: list[ComparisonImageSet] = field(default_factory=list)


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

#: Target display widths for lossy images (px).
LOSSY_TARGET_WIDTHS: list[int] = [600, 900, 1400]

#: Number of decimal places kept by SVGO when optimising SVG files.
#: Matplotlib typically emits 6+ significant digits; 1 is sufficient for
#: screen rendering and yields the greatest file-size savings.
SVG_PRECISION: int = 1

#: Absolute path to the SVGO configuration file bundled with this project.
#: The config enables ``removeStyleElement`` on top of the default preset.
_SVGO_CONFIG: Path = Path(__file__).resolve().parent.parent / "config" / "svgo.config.mjs"

#: AVIF quality for lossy pipeline (0–100 scale, where 100 is lossless).
# YUV444 chroma is used to avoid sub-sampling artefacts on synthetic / visualisation content,
# so a lower quality setting can be used without introducing visible colour degradation.
AVIF_QUALITY: int = 60

#: WebP quality for lossy pipeline (0–100 scale).
WEBP_QUALITY: int = 85


# ---------------------------------------------------------------------------
# SVG optimisation
# ---------------------------------------------------------------------------


def optimise_svg(
    source: Path,
    dest: Path,
    *,
    precision: int = SVG_PRECISION,
) -> Path:
    """Optimise an SVG file with SVGO and write the result to *dest*.

    Runs ``npx svgo`` using :data:`_SVGO_CONFIG`, which enables
    ``removeStyleElement`` on top of the default preset, combined with
    ``--multipass`` and the given floating-point *precision*.

    ``removeStyleElement`` strips the embedded ``<style>`` block that
    Matplotlib writes into every SVG.  Those rules are redundantly
    inlined on individual elements, so their removal is lossless and
    typically yields the largest share of size reduction.

    If SVGO is unavailable or fails the source file is copied verbatim
    and a warning is printed so that report generation is never blocked.

    Args:
        source: Path to the original ``.svg`` file.
        dest: Destination path (parent directories are created as needed).
        precision: Number of digits in the fractional part of numeric
            values.  Lower values yield smaller files at the cost of
            sub-pixel accuracy — ``1`` is sufficient for screen rendering.

    Returns:
        Path to the written file (*dest*).
    """
    import shutil

    dest.parent.mkdir(parents=True, exist_ok=True)
    cmd = [
        "npx",
        "--yes",
        "svgo",
        "--config",
        str(_SVGO_CONFIG),
        "--precision",
        str(precision),
        "--multipass",
        "--quiet",
        "-i",
        str(source),
        "-o",
        str(dest),
    ]
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        print(
            f"  Warning: SVGO failed for {source.name} "
            f"(exit {result.returncode}) — copying verbatim.\n"
            f"  {result.stderr.strip()}"
        )
        shutil.copy2(source, dest)
    return dest


# ---------------------------------------------------------------------------
# Lossless pipeline (fragment comparison grids)
# ---------------------------------------------------------------------------


def optimise_lossless(
    source: Path,
    output_dir: Path,
    report_root: Path,
    *,
    alt: str = "",
) -> OptimisedImage:
    """Copy a lossless comparison grid as a single lossless WebP.

    Fragment comparison grids use nearest-neighbour zoom with text
    labels rendered at a matching font size.  Down-scaling to 2× or 1×
    would preserve pixel fidelity of the image fragments but ruin the
    label text, and lossless WebP compresses the repeating 3×3 pixel
    blocks so efficiently that the size saving would be negligible.
    Therefore we serve a single full-resolution variant.

    Args:
        source: Path to the original lossless comparison grid.
        output_dir: Directory where the variant will be written.
        report_root: Root of the report output tree (for relative paths).
        alt: Alt-text for the image.

    Returns:
        :class:`OptimisedImage` with a single lossless WebP variant.
    """
    output_dir.mkdir(parents=True, exist_ok=True)
    stem = source.stem

    dst = output_dir / f"{stem}.webp"
    with Image.open(source) as img:
        orig_w, orig_h = img.size
        img.save(dst, format="WEBP", lossless=True)

    variant = ImageVariant(
        path=dst,
        rel_path=str(dst.relative_to(report_root)),
        width=orig_w,
        height=orig_h,
        media_type="image/webp",
        lossless=True,
    )

    result = OptimisedImage(source_path=source, alt=alt, kind="lossless")
    result.variants["image/webp"] = [variant]
    result.default = variant
    return result


# ---------------------------------------------------------------------------
# Lossy pipeline (distortion maps, annotated originals)
# ---------------------------------------------------------------------------


def _encode_avif(src_png: Path, dst: Path, quality: int = AVIF_QUALITY) -> ImageVariant:
    """Encode a PNG as lossy AVIF.

    Uses ``avifenc`` with YUV444 chroma to avoid sub-sampling artefacts
    on synthetic / visualisation content.
    """
    dst.parent.mkdir(parents=True, exist_ok=True)
    cmd = [
        "avifenc",
        "-q",
        str(quality),
        "--yuv",
        "444",
        "--speed",
        "4",
        str(src_png),
        str(dst),
    ]
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        msg = f"avifenc failed: {result.stderr}"
        raise RuntimeError(msg)
    with Image.open(dst) as img:
        w, h = img.size
    return ImageVariant(
        path=dst,
        rel_path="",
        width=w,
        height=h,
        media_type="image/avif",
    )


def _encode_webp_lossy(src_png: Path, dst: Path, quality: int = WEBP_QUALITY) -> ImageVariant:
    """Encode a PNG as lossy WebP."""
    dst.parent.mkdir(parents=True, exist_ok=True)
    cmd = [
        "cwebp",
        "-q",
        str(quality),
        "-m",
        "6",
        str(src_png),
        "-o",
        str(dst),
    ]
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        msg = f"cwebp failed: {result.stderr}"
        raise RuntimeError(msg)
    with Image.open(dst) as img:
        w, h = img.size
    return ImageVariant(
        path=dst,
        rel_path="",
        width=w,
        height=h,
        media_type="image/webp",
    )


def _resize_lanczos(src: Path, target_width: int, dst: Path) -> Path:
    """Resize *src* to *target_width* (keeping aspect ratio) via Lanczos.

    Saves as PNG for subsequent encoding.  Returns *dst*.
    """
    with Image.open(src) as img:
        if img.width <= target_width:
            # No need to resize — just copy
            dst.parent.mkdir(parents=True, exist_ok=True)
            img.save(dst, format="PNG")
            return dst
        ratio = target_width / img.width
        new_h = round(img.height * ratio)
        resized = img.resize((target_width, new_h), Image.Resampling.LANCZOS)
        dst.parent.mkdir(parents=True, exist_ok=True)
        resized.save(dst, format="PNG")
    return dst


def optimise_lossy(
    source: Path,
    output_dir: Path,
    report_root: Path,
    *,
    alt: str = "",
    target_widths: list[int] | None = None,
) -> OptimisedImage:
    """Create lossy AVIF + WebP variants at multiple widths.

    Args:
        source: Path to the source image (any Pillow-readable format
            or lossless WebP).
        output_dir: Directory for the generated variants.
        report_root: Report output root for computing relative paths.
        alt: Alt-text for the ``<img>`` element.
        target_widths: Desired widths; defaults to :data:`LOSSY_TARGET_WIDTHS`.

    Returns:
        :class:`OptimisedImage` with AVIF and WebP variants.
    """
    if target_widths is None:
        target_widths = list(LOSSY_TARGET_WIDTHS)

    output_dir.mkdir(parents=True, exist_ok=True)
    stem = source.stem

    # Read original dimensions
    with Image.open(source) as img:
        orig_w = img.width

    # Ensure we always include the original width if it's smaller than
    # the largest target, and filter out widths larger than the original.
    widths = sorted({w for w in target_widths if w < orig_w} | {orig_w})

    result = OptimisedImage(source_path=source, alt=alt, kind="lossy")
    avif_variants: list[ImageVariant] = []
    webp_variants: list[ImageVariant] = []

    for w in widths:
        # Resize to PNG intermediate
        resized_png = output_dir / f"{stem}_{w}px.png"
        _resize_lanczos(source, w, resized_png)

        # AVIF
        avif_path = output_dir / f"{stem}_{w}px.avif"
        av = _encode_avif(resized_png, avif_path)
        av.rel_path = str(avif_path.relative_to(report_root))
        avif_variants.append(av)

        # WebP lossy
        webp_path = output_dir / f"{stem}_{w}px.webp"
        wv = _encode_webp_lossy(resized_png, webp_path)
        wv.rel_path = str(webp_path.relative_to(report_root))
        webp_variants.append(wv)

        # Clean up intermediate PNG
        resized_png.unlink(missing_ok=True)

    result.variants["image/avif"] = sorted(avif_variants, key=lambda v: v.width)
    result.variants["image/webp"] = sorted(webp_variants, key=lambda v: v.width)

    # Default fallback: medium WebP
    mid_idx = len(webp_variants) // 2
    result.default = webp_variants[mid_idx] if webp_variants else None

    return result


# ---------------------------------------------------------------------------
# Discovery and orchestration
# ---------------------------------------------------------------------------


def _strategy_label(strategy: str) -> str:
    """Human-readable strategy label."""
    return {
        "average": "Average Distortion",
        "variance": "Parameter Sensitivity",
    }.get(strategy, strategy.title())


def _classify_image(filename: str) -> str:
    """Classify a comparison output file into a category.

    Returns one of: ``"fragment_grid"``, ``"distmap_grid"``,
    ``"distortion_map"``, ``"original_annotated"``, or ``"unknown"``.
    """
    name = filename.lower()
    if name.startswith("comparison"):
        return "fragment_grid"
    if name.startswith("distortion_map_comparison"):
        return "distmap_grid"
    if name.startswith("distortion_map_"):
        return "distortion_map"
    if name.startswith("original_annotated"):
        return "original_annotated"
    return "unknown"


def discover_and_optimise(
    analysis_dir: Path,
    study_id: str,
    output_dir: Path,
    report_root: Path,
) -> StudyComparisonImages:
    """Discover comparison images and create optimised variants.

    Scans ``<analysis_dir>/<study_id>/comparison/`` for output files
    generated by :func:`src.comparison.generate_comparison`, optimises
    them for web delivery, and returns structured metadata for template
    rendering.

    Args:
        analysis_dir: Root analysis directory (e.g. ``data/analysis``).
        study_id: Study identifier.
        output_dir: Report output directory (e.g. ``data/report``).
        report_root: Same as *output_dir* (used for relative path
            computation).

    Returns:
        :class:`StudyComparisonImages` ready for template rendering.
    """
    comparison_dir = analysis_dir / study_id / "comparison"
    if not comparison_dir.is_dir():
        return StudyComparisonImages(study_id=study_id)

    result = StudyComparisonImages(study_id=study_id)
    img_output_base = output_dir / "comparison" / study_id

    for strategy_dir in sorted(comparison_dir.iterdir()):
        if not strategy_dir.is_dir():
            continue
        strategy = strategy_dir.name
        if strategy not in ("average", "variance"):
            continue

        # Check for per-resolution subdirectories
        subdirs = sorted(d for d in strategy_dir.iterdir() if d.is_dir() and d.name.startswith("r"))
        if subdirs:
            # Resolution study: process each sub-directory
            for res_dir in subdirs:
                image_set = _process_directory(
                    res_dir,
                    strategy,
                    img_output_base / strategy / res_dir.name,
                    report_root,
                    resolution=res_dir.name,
                )
                result.sets.append(image_set)
        else:
            # Non-resolution study: process the strategy directory directly
            image_set = _process_directory(
                strategy_dir,
                strategy,
                img_output_base / strategy,
                report_root,
            )
            result.sets.append(image_set)

    return result


def _process_directory(
    src_dir: Path,
    strategy: str,
    out_dir: Path,
    report_root: Path,
    *,
    resolution: str | None = None,
) -> ComparisonImageSet:
    """Optimise all comparison images in a single directory.

    Args:
        src_dir: Directory containing comparison output files.
        strategy: ``"average"`` or ``"variance"``.
        out_dir: Output directory for optimised files.
        report_root: Root for relative path computation.
        resolution: Optional resolution label (e.g. ``"r720"``).

    Returns:
        Populated :class:`ComparisonImageSet`.
    """
    image_set = ComparisonImageSet(strategy=strategy, resolution=resolution)

    for src_file in sorted(src_dir.iterdir()):
        if not src_file.is_file():
            continue
        if src_file.suffix.lower() not in (".webp", ".png"):
            continue

        category = _classify_image(src_file.name)
        if category == "unknown":
            continue

        if category == "fragment_grid":
            opt = optimise_lossless(
                src_file,
                out_dir / "fragments",
                report_root,
                alt=f"Fragment comparison — {src_file.stem}",
            )
            image_set.fragment_grids.append(opt)

        elif category == "distmap_grid":
            opt = optimise_lossy(
                src_file,
                out_dir / "distmaps",
                report_root,
                alt=f"Distortion map comparison — {src_file.stem}",
            )
            image_set.distmap_grids.append(opt)

        elif category == "distortion_map":
            opt = optimise_lossy(
                src_file,
                out_dir / "overview",
                report_root,
                alt=f"Aggregated distortion map ({strategy})",
            )
            image_set.distortion_map = opt

        elif category == "original_annotated":
            opt = optimise_lossy(
                src_file,
                out_dir / "overview",
                report_root,
                alt="Original image with selected fragment highlighted",
            )
            image_set.original_annotated = opt

    return image_set


# ---------------------------------------------------------------------------
# Template helpers
# ---------------------------------------------------------------------------


def srcset_lossless(opt: OptimisedImage) -> str:
    """Build a ``srcset`` attribute value for a lossless :class:`OptimisedImage`.

    Uses width descriptors (``<width>w``).
    """
    parts = []
    for v in opt.variants.get("image/webp", []):
        parts.append(f"{v.rel_path} {v.width}w")
    return ", ".join(parts)


def picture_html(opt: OptimisedImage, *, css_class: str = "", sizes: str = "") -> str:
    """Render a ``<picture>`` element for a lossy :class:`OptimisedImage`.

    Emits ``<source>`` elements for AVIF and WebP, with a ``<img>``
    fallback.
    """
    if not sizes:
        sizes = "(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1100px"

    lines = ["<picture>"]

    # AVIF sources
    avif_variants = opt.variants.get("image/avif", [])
    if avif_variants:
        avif_srcset = ", ".join(f"{v.rel_path} {v.width}w" for v in avif_variants)
        lines.append(f'  <source type="image/avif" srcset="{avif_srcset}" sizes="{sizes}">')

    # WebP sources
    webp_variants = opt.variants.get("image/webp", [])
    if webp_variants:
        webp_srcset = ", ".join(f"{v.rel_path} {v.width}w" for v in webp_variants)
        lines.append(f'  <source type="image/webp" srcset="{webp_srcset}" sizes="{sizes}">')

    # Fallback <img>
    fallback = opt.default
    if fallback is None and webp_variants:
        fallback = webp_variants[len(webp_variants) // 2]
    if fallback is None and avif_variants:
        fallback = avif_variants[len(avif_variants) // 2]

    cls_attr = f' class="{css_class}"' if css_class else ""
    if fallback:
        lines.append(
            f'  <img src="{fallback.rel_path}" alt="{opt.alt}" '
            f'loading="lazy" decoding="async" '
            f'width="{fallback.width}" height="{fallback.height}"{cls_attr}>'
        )
    lines.append("</picture>")
    return "\n".join(lines)


def img_srcset_html(opt: OptimisedImage, *, css_class: str = "", sizes: str = "") -> str:
    """Render an ``<img>`` with ``srcset`` for a lossless :class:`OptimisedImage`."""
    if not sizes:
        sizes = "(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1100px"

    webp_variants = opt.variants.get("image/webp", [])
    srcset = ", ".join(f"{v.rel_path} {v.width}w" for v in webp_variants)

    fallback = opt.default
    if fallback is None and webp_variants:
        fallback = webp_variants[len(webp_variants) // 2]

    cls_attr = f' class="{css_class}"' if css_class else ""
    if fallback:
        return (
            f'<img srcset="{srcset}" sizes="{sizes}" '
            f'src="{fallback.rel_path}" alt="{opt.alt}" '
            f'loading="lazy" decoding="async" '
            f'width="{fallback.width}" height="{fallback.height}"{cls_attr}>'
        )
    return ""
